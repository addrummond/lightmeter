HFSDP
=====


Overview
--------

HFSDP is a master/slave protocol. Communication is initiated, and ended, by the
master. Data can be transmitted in both directions.


Identifiers
-----------

Each master and slave has two identifiers. The first is a unique 8-byte
identifier. The second is an 8-byte 'type'.


Frequency bands
---------------

HFSDP makes us of the following frequencies.

    * 18KHz data channel
    * 20KHz clock

A sine wave on each of these frequencies is used to encode a rectangular-wave
signal using amplitude modulation. The rectangular wave should be approximated
using the first 11 terms of the fourier series:

    (sum from n = 1 to 11 [ (2*sin(PI*n*d)*cos(2*PI*n*(t-(d/2))*f))/(n*PI) ]) + d

        where 0 <= d <= 1 controls the duty cycle, and
              f is frequency, t is time

The above equation derives a wave that starts high and remains high for the
period specified by the duty cycle.

The clock and data channels encode a 126 baud binary signal. Thus, in the case
where the signal transmitted is 1010..., d = 0.5 and f = 126. If the signal is
11001100..., d = 1/2 and f = 126/2. If the signal is 11101110..., d = 3/4 and
f = 126/4.

Binary signals should be broken up into blocks of i zeroes followed by k ones
(in the case where the signal begins with a zero), or i ones followed by k zeroes
(in the case where the signal begins with a one). The appropriate rectangular wave
can then be generated for each block. The protocol is such that no more than
eight zeroes or ones will ever be transmitted in sequence. The maximum required
duty cycle is therefore 8/9. The 11-term fourier series generates a good square
wave approximation up to this duty cycle.

Wolfram alpha expression for approximate square wave equation with f=10, d=0.5:

    plot sum (((2*sin(pi*n*0.5)*cos(2*pi*n*0.5*(x-(0.5/10))*10)))/(n*pi)) + 0.5/11, n = 1 to 11 from x = 0 to x = 1


Transmission of bytes
---------------------

The data channel is read on both the rising and falling edges of the clock
signal. Each byte is transmitted in little-endian form as a sequence of 9 bits.
The final bit is set to 1 if the number of 1s in the preceding 8 bits is even
(0 is considered even), and to 0 otherwise.

After each sequence of eight bytes, a parity byte is transmitted.

Initiation
----------

The master initiates communication with the slave by sending out a signal on two
FP500s:

|              | A mode | I mode |
|--------------|--------|--------|
| First FP500  | 5000   | 21000  |
| Second FP500 | 9000   | 26000  |

The signal is generated by switching between the following two states at 1000Hz:

* State 1: First FP500 is on and second is off.
* State 2: Second FP500 is on and first is off.

The slave responds after detecting a sequence of 16 on-off or off-on state
changes on at least one of the two FP500s. The slave's response follows the same
pattern as the master's signal but uses different FP500s:

|              | A mode | I mode |
|--------------|--------|--------|
| First FP500  | 7000   | 23000  |
| Second FP500 | 11000  | 29000  |

Once the master detects 16 state changes on at least one of these FP500s,
the protocol enters the frequency negotiation phase.


Frequency negotiation
---------------------

Using the two FP500s given in the previous section, the slave sends a list of
8 frequencies on which it is prepared to communicate. If the slave cannot
communicate on 8 different frequencies, it must send 8 anyway and use duplicates
to pad the list. Each frequency is given a unary encoding as a series of
'blips', where each blip represents 1000Hz. A single blip is encoded by
switching both FP500s either from off to on or on to off. A given frequency is
terminated by setting both FP500s flat for at least 16 cycles
(i.e. 16/1000ths of a second) and at most 64 cycles.

The master decides which of the slave's available frequencies will be used.
It responds by sending a single frequency using the same method described in
the previous paragraph.

The slave acknowledges by switching between the following two states at 1000Hz
using FP500(x) where x is the frequency chosen by the master:

* State 1: FP500(x) is on.
* State 2: FP500(x) is off.

Once the master receives this acknowledgment, the protocol enters the message
phase.


Message phase
----------

The frequency x selected by the master defines four FP500s:

* Master clock: FP500(x)
* Master data:  FP500(x+2000)
* Slave clock:  FP500(x+4000)
* Slave data:   FP500(x+6000)

By default, communication occurs at 1000Hz. The master and slave may exchange
messages to negotiate a higher speed at any time (or to return to a lower
speed). The frequency selected at any given time is termed the clock frequency.
It is always the same for the slave and the master at any given time.

The master and slave clock FP500s should, at any given time, either be turned off
or switching on and off at the clock frequency. On each state change from off
to on, the state of the corresponding data FP500 is checked. If it is on, this
encodes a 1; if it is off, this encodes a 0.

Initially, the slave is waiting for the master to send it a message.
